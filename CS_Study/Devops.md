
<details>
<summary><b>Docker란 ?</b></summary>
<div markdown="1">

* Docker는 컨테이너 기술을 사용하여 애플리케이션에 필요한 **환경을 신속하게 구축**하고 테스트 및 배포를 할 수 있게 해주는 플랫폼
* Docker는 도커파일에 운영체제, 실행 명령어를 저장해 두고 실행하면 항상 동일한 환경이 구성하여 인프라를 따로 설정하지 않아도 된다.
* 즉, 인프라를 코드화해서 관리할 수 있다. -> IaC(Infrastructure as Code)가 가능 하다
* Docker Image 란 컨테이너 생성(실행)에 필요한 모든 파일과 설정값(환경)을 지닌 것으로, 컴파일된 실행 파일을 묶은 형태이다.
* Docker Container 란 도커 이미지를 실행한 상태를 나타낸다.
* 따라서 도커를 이용하면 쉽고 빠른 실행 환경 구축이 가능하다.

</div>
</details>


<details>
<summary><b>Jenkins란?</b></summary>
<div markdown="1">

* Jenkins 로고를 보면 웨이터가 있음. 웨이터는 쉐프가 만든 음식을 받아서 고객에게 전달해주는 역할을함
* 비슷한 의미로 Jenkins는 개발자의 요청을 받아서 빌드와 배포를 해주는 툴이다.
* 다른 주요 기능으로는 Batch가 있다. 요청을 모아서 주기적으로 처리해주는 역할을 한다.

</div>
</details>


<details>
<summary><b>Jenkins를 이용한 Worker 인스턴스 접속</b></summary>
<div markdown="1">

* Jenkins를 이용하여 Worker인스턴스(서버임)에 안전하게 접속하기 위해서 SSH 접속을 이용했다.
* Jenkins에서 공개키, 개인키를 만들고 Worker인스턴스에 해당 공개키를 복사하여 주면 된다.
* 그러면 오직 Jenkins만 Worker에 SSH로 접속할 수 있게 된다.

</div>
</details>


<details>
<summary><b>Forward Proxy와 Reverse Proxy 란?</b></summary>
<div markdown="1">

* Forward Proxy
    * 클라이언트가 요청을 보내면 직접 서버와 통신하는게 아니라 프록시 서버에 캐싱된 내용이나
    * 프록시 서버가 본서버에 요청을 하고 받은 응답을 클라이언트에게 전달해 주는 역할을 함
    * Forward 프록시는 클라이언트를 숨겨주는 역할도 함
* Reverse Proxy
    * Forward Proxy와 반대의 역할을 함
    * 리버스 프록시는 서버를 숨겨주는 역할도 함

</div>
</details>


<details>
<summary><b>Nginx란 ?, Apache와 비교</b></summary>
<div markdown="1">

* 트래픽이 많은 웹사이트의 확장성을 위해 개발된 경량의 고성능 웹서버
* 리버스 프록시 역할을 함 : 무중단 배포에 사용될 수 있음
* 로드 밸런싱 : 서버에 가해지는 부하를 분산해주는 기술
* Apache는 클라이언트 접속마다 Process 혹은 Thread 를 생성하는 구조를 가지고 있다.
    * 그 만큼 CPU와 메모리 사용이 증가하고 생성비용이 크기때문에 대용량 요청에 적합하지 않다.
    * 반면 Nginx는 하나의 프로세스 내에서 비동기 방식으로 작업을 처리하기 때문에 성능이 더 뛰어나다

</div>
</details>


<details>
<summary><b>무중단 배포 : Rolling</b></summary>
<div markdown="1">

* **배포** 란 새로 개발된 코드를 패키징하여 서버에서 새로운 버전의 애플리케이션을 실행하도록 하는 행위를 뜻함
* **무중단 배포** 란 서비스의 중단 없이 이루어지는 배포를 뜻함
* 롤링 무중단 배포는 사용 중인 인스턴스 내에서 새 버전을 점진적으로 교체하는 것으로 무중단 배포의 가장 기본적인 방식
* 롤링 배포 장점 
    * 인스턴스마다 차례로 배포를 진행하기에 상황에 따라 손쉽게 롤백이 가능하다.
    * 추가적인 인스턴스를 늘리지 않아도 된다.
    * 간편한 관리
* 롤링 배포 단점
    * 새 버전을 배포할때 인스턴스의 수가 감소하기 때문에 사용중인 인스턴스에 트래픽이 몰릴 수 있다.
    * 배포가 진행될때 구버전과 신버전이 공존하기에 호환성 문제가 발생할 수 있다.
        * 업데이트 된 버전의 서버2, 안된 서버2개가 있으면 사용자들은 균일한 서비스를 받지 못할 수도 있는것임

</div>
</details>


<details>
<summary><b>서버가 죽는 이유?</b></summary>
<div markdown="1">

* 일부 요청이 실패한다.
* 모든 요청이 실패한다.
    * 네트워크에 장애가 생김
    * 서버 자체에 문제가 생김
    * 지나치게 높은 트래픽으로 행이 걸렸을때
        1. 톰캣으로 사용자의 요청이 들어오면 톰캣 내부의 큐에 요청이 들어감
        2. 놀고 있는 쓰레드가 있으면 요청을 받아서 처리함
        3. 요청이 많아지면, 톰캣의 큐의 사이즈보다 더 많은 요청이 오게 되고 이때부터 요청이 실패되어 버려짐
        4. 또는 큐에 들어오고 나서 처리되는데 까지 30초의 시간이 지나면 요청은 타임아웃 처리됨 -> 요청 실패되어 버려짐

</div>
</details>


<details>
<summary><b>메시지 큐기능? Rabbit MQ, Kafka ?</b></summary>
<div markdown="1">

* 요청이 많은 경우 톰캣(Tomcat)의 큐의 사이즈를 넘어가거나 타임아웃 처리될 수 있음
* 톰캣이 종료될 경우 요청이 다 날아가 버림
    * 메시지 큐를 이용하면 디스크에 저장하는 등 여러가지 옵션을 제공
* 메시지 큐는 비동기적으로 동작한다. -> 요청을 저장했다가 나중에 처리할 수 있는것
    * DB속도와 무관하게 요청 메시지를 누락없이 저장했다가 처리할 수 있음
* Application간의 의존성 제거
    * Application A에서 Application B의 API호출을 통해 데이터를 전달하는 상황에서
    * Application B가 종료되는 순간 A가 보낸 데이터는 유실됨
    * 즉, A는 B에 대한 의존성이 생기는것
    * 이때 메시지 큐를 이용하면 요청에 대한 내용을 보존할 수 있음
* 신뢰성
    * 요청 메시지가 실패하면 다시 큐에 넣어 재실행할 수 있음
* 여러개의 큐를 사용할 수도 있음
    * 큐 사이의 데이터를 지속적으로 동기화 하여
    * 어느 한쪽 큐에서 장애가 발생하더라도 전체 큐 서비스에 영향이 없도록 구성할 수 있다.

* kafka는 클러스터를 통해 병렬처리가 주요 차별점인 만큼 방대한 양의 데이터를 처리할 때 장점이 부각된다. 
* RabbitMQ는 데이터 처리보단 Manage UI를 제공하는 만큼 관리적인 측면이나, 다양한 기능 구현을 위한 서비스를 구축할 때 장점이 부각

</div>
</details>